# React Component

## React UI 구성 방법

React UI를 구성할 때 5단계를 거친다. 처음 두 단계는

1. UI 간단하게 component로 나눠보기 - UI를 컴포넌트 계층구조로 나누기
2. react의 정적인 버전(상호작용성을 배제한)을 만든다.

2단계 -> 이때 props는 데이터 전달용으로 쓰는데, state는 상호작용성을 위한 것이므로 정적인 react코드 작성시에는 추가하지 않는다.

## JSON

javascript 객체 표기법을 활용한 data 교환용 표준 포맷. 더글라스 크록포드(Douglas Crockford)가 만들었다. js 외에도 언어에 구애받지 않고 웹상에서 구조화된 데이터를 주고 받을 때 표현방식으로 사용한다.
보낼때는 Stringify 해서 문자열로 만들어 전송에 용이하게 만들어 보낸다.
받은 이후에는 문자열 형태의 데이터를 parsing 해서 사용하기 좋게 JSON 객체 형식으로 변환한다. 직렬화 역직렬화와 유사하다는 생각이 든다.

B/E 에서는 데이터를 JSON의 형태로 받아오게 되는데, 데이터를 받기 위한 API로 REST API 방식 혹은 GraphQL이 있다.

## DSL(Domain-Specific Language) - 도메인 특화 언어

특정 도메인/문제에 최적화된 언어. React에서 쓰는 DSL에는 JSX(JS XML)가 있다. UI를 구성하는 문제(도메인)이 있고, 해당 문제를 XML 비슷한 구문으로 구성해린다. language는 아니고 syntax extension이지만 특정 task를 위한 syntax 도 DSL로 친다.

B/E에서 API를 통해 JSON 데이터를 받아오면 F/E 에서 UI를 구성하기위한 목적의 DSL - JSX(선언형 - HTML 처럼 대상을 명시)를 사용한다.

## 선언형 프로그래밍

명령형 프로그래밍이 아닌 프로그래밍 패러다임. 수행 대상에 대한 선언이나 함수호출을 하는 식으로 자료를 처리하는 프로그래밍 패러다임

* '무엇을' 할 것인가? WHAT?
* 식 / 선언으로 수행됨
* Expression(식) : 함수 호출 등.
* HTML, CSS , XML, JSX : 선언형. 무엇을 표시할 것인지 묘사한다.
* 목표를 명시한다.
* 함수형 프로그래밍 언어 : 수학적 함수 계산으로 취급. 프로그램 상태 값을 바꾸지 않음

## 명령형 프로그래밍

전역적인 상태와 상태를 변경시키는 명령문을 순차 수행하는 프로그래밍 패러다임

* '어떻게' 할 것인가? HOW?
* C, Java
* 명령형. 이렇게 저렇게 해라.
* 알고리즘을 명시한다.
* 상태/ 변수를 변경
* Statement(문) - for, if, while, switch 등

## REST API

### REST API 란?

#### 최초언급

REST 최초정의는 roy fielding의 박사논문 에서 언급되었다.

[Architectural Styles and the Design of Network-based Software Architectures](https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm)

최초정의 - REST architecture style : 복잡하고 분산된 시스템을 구성하기 위한 추상화한 아키텍처 스타일. component 역할/ 상호작용시 제약조건 / 중요 data element 해석에 집중하려고 component 구현/ protocol 구문 세부사항은 일부러 무시함

-> 그렇기에 보면 큰 그림에서 REST 방식은 어떻게 돌아가는지 정도만 나타나 있지 다른 언어나 framework의 docs처럼 공식 문서의 문법에 대한 딱 정해진 세부사항은 없는 듯 하다.

제약사항 - 해당 제약사항을 통해 간단하고, 확장성, 가시성, 사용성을 확보한 웹 서비스 구성이 가능하다. HTTP 저자가 만들었기에 http 특성도 일부 있다.

* 클라이언트 - 서버 아키텍처 스타일 - UI 관심사와 데이터 관심사를 분리하는 관심사의 분리가 핵심. 분리를 하면 플랫폼 별 UI 이식성 향상 및 서버 확장성도
꾀할 수 있다.

* 무상태 - 요청시에 모든 정보를 담아야 하며 이전 요청의 맥락 그런건 기대하면 안된다. 이전에 보냈던 정보를 똑같이 담아야하는 트레이드 오프는 있지만, 가시성(요청 관련 정보를 다 보내므로), 확장성(상태 저장 안해서 자원 해제가 용이) 측면에서 감수할만하다.
-> 확장성에 대해서 언급하자면, 상태, 즉 컨텍스트를 가진다는 것은 그 맥락을 서버 전체가 가지고 있어야 한다는 것과 동일하다. 그렇지 않으면 이전 요청을 받았던 서버만 응답이 가능하기에 서비스가 되지 않는다. 서버가 1대라고 가정하면 상관이 없을 것이다. 하지만 서버가 늘어날 수 있는 가능성(확장성)을 고려하면 무상태 방식으로 가는 것이 요청의 중복이 일어날 지언정 더 적절하다고 본다. 가시성은 말 그대로 이전 요청의 상태(컨텍스트)를 허용한다면 암묵적인 정보가 해당 요청시에 들어가게 되므로 보이지 않기에 나온 것이다. 무상태 서버 에서는 요청 처리에 필요한 모든 정보가 명시적으로 드러나기에 가시성 면에서 상태 서버 방식보다 낫다 .

* 캐시 - 이전 응답 정보 중 재사용할만한 것들을 캐시로 저장해서 재활용하면 자원 낭비를 안해도 되어서 효율적이고 사용성도 좋아진다.
-> 똑같은 요청을 계속 보내는데 그 요청이 GET 처럼 멱등적이라면 굳이 일일이 서버의 자원을 요청할 필요가 없는 것 처럼 말이다. 그리고 똑같은 것을 굳이 가져온다고 쳐도 클라이언트 - 서버 간 네트워크를 통해서 받아오는 것 보다 클라이언트 상의 브라우저 캐시에 접근해서 가져오는 것이 속도면에서 훨씬 빠르고 말이다. 물론 이것은 가져오는 자원이 급격하게 변하지 않는다는 전제에서 성립한다.

* 균일한 인터페이스 - component 간 통합 인터페이스 때문에 더 간단해지고 상호작용하는것도 더 가시적이다. 서비스 별 분리되어 있기에 독립적으로 발전 가능하다. 정보 전달시 해당 상황에 필요없는 정보도 표준화된 규격에 맞춰서 보내야 한다는 점은 비효율적이나(trade off), 대용량 하이퍼미디어 전송을 용이하게 해주므로 어느정도 감수할만하다.

* 계층적(layered) 시스템 - 계층으로 나누면 컴포넌트에서 상호작용하는 맞닿은 계층 너머의 정보를 알 수 없다. 서비스 접근도 선별적으로 통제하는 등 component 관리도 간단하게 할 수 있다.
-> 계층이 많이 나뉘면 그에 따른 오버헤드 및 성능저하도 생기나, 캐시 사용으로 충당이 가능하다고 여겼던 것 같다. 통합 인터페이스 또한 대용량 파일들을 웹으로 처리하기 용이하게 최적화되어 있어 실제로 웹 사용시에 이로인한 큰 불편을 느끼지는 못한다.

선택 제약 조건(Optional)

* code-on-demand : 클라이언트 상에서 script 코드 다운 혹은 실행을 가능하게끔 허용한다. 이렇게 클라이언트 쪽 기능 확장을 가능하게하면, 확장성을 고려해서 클라이언트 기능을 처음에 간단하게 구성할 수 있다. 나중에 시스템을 충분히 확장할 수 있으니 말이다.

#### AWS 문서

[AWS - RESTful API](https://aws.amazon.com/ko/what-is/restful-api/)

정의 - API 작동 방식에 대한 조건(제약사항)을 걸어주는 SW architecture이다. REST를 통해 대규모 통신을 안정적으로 할 수있게끔 방향성과 제약사항이 제시되었다. 해당 아키텍처를 따라 설계한 API를 REST(ful) API라 하고 REST 아키텍처를 구현한 web 서비스를 RESTful web 서비스라고 한다.

인터페이스 원칙

1. 자원의 식별 : 요청이 리소스를 식별해야 한다. 그러기 위해 균일한 리소스 식별자를 사용한다.
2. 메시지를 통한 리소스의 조작 : 클라이언트는 리소스를 수정/삭제할 수 있는 충분한 정보가 담긴 resource representation를 받아야 한다. 그러기 위해 서버는 리소스 관련 메타데이터를 보낸다.
3. 자기서술적 메시지 : 클라이언트는 표현을 추가 처리할 수 있는 정보를 받아야한다. 그러기 위해 서버는 리소스를 적절하게 사용하는 방법 관련 메타데이터가 담긴 메시지를 보내야한다. -> 표현이 표현을 사용하는 방법을 같이 보내는 것은 간단히 말하면 나 사용 설명서이다.
4. 애플리케이션 상태에 대한 엔진으로서 하이퍼미디어 : 클라이언트는 작업을 완료하는 데 필요한 기타 리소스 관련 정보를 받아야 한다. 그러기 위해 서버는 representation에 하이퍼링크를 넣어서 추가 리소스를 동적으로 검색할 수 있게 한다.

RESTful API의 이점

1. 확장성
2. 유연성 - 클라이언트 서버 분리를 통한 독립적인 발전이 가능. roy fielding 은 이것을  independent evolvability(독립적인 진화가능성) 이라고 언급한다.
3. 독립성 - REST API는 사용 기술과 독립적이기에 프로그래밍 언어에 구애받지 않는다.

### GraphQL은 왜 등장했는가?

API를 위한 쿼리 언어이자, 기존 데이터로 해당 쿼리 수행하기 위한 기반 런타임이다. API의 데이터에 대한 완벽하고 이해가능한 설명을 제공한다. 그리고 필요로 하는 데이터만 정확히 질의 가능하다. 기존 query에 영향을 끼치지 않고 새 field/type을 추가하는 것(버전 없이 API 발전)이 가능하다. 그리고 강력한 개발자 도구를 제공한다.

data를 정의하는 type system을 이용하는 server side runtime이다. GraphQL은 DB나 storage engine에 연결되지 않고 코드/ 데이터에 의해 지원받는다.

### REST API vs GraphQL

모두 클라이언트와 서버 간의 통신을 위한 웹 API 지만 차이가 있다.

REST API는 HTTP 프로토콜의 구조와 제약 사항을 따르는 아키텍처 스타일. REST API는 자원(resource)을 중심으로 설계되며, 자원을 URI(Uniform Resource Identifier)로 나타내고, 자원에 대한 행위는 HTTP 메소드(GET, POST, PUT, DELETE 등)를 사용하여 표현한다. REST API는 네트워크 캐싱, 스케일링, 로드 밸런싱 등의 이점을 제공하지만, 복잡한 데이터 구조를 처리하기 어려운 단점이 있다.

GraphQL은 Facebook에서 개발한 쿼리 언어 및 런타임. GraphQL은 REST API의 단점을 보완하고, 클라이언트 측에서 쿼리를 작성하고, 서버 측에서 응답을 생성하는 방식으로 동작한다. GraphQL은 클라이언트가 필요로 하는 데이터를 정확하게 요청할 수 있도록 해주며, 서버 측에서는 클라이언트의 요청에 대해 필요한 데이터만을 반환한다. GraphQL은 복잡한 데이터 구조를 다루는 데 유용하며, 클라이언트 측에서 쿼리를 작성하는 데에는 높은 학습 곡선이 필요하다.

#### 표로 비교하는 REST API, GraphQL

|                | **REST API** | **GraphQL**|
|:---:|:---:|:---:|
| 정의 | REST API는 자원 중심의 아키텍처 스타일 | GraphQL은 데이터 중심의 쿼리 언어 |
| 무엇을 하는가 | REST API는 HTTP 메소드를 사용, 자원에 대한 행위를 나타냄 | GraphQL은 단일 엔드포인트를 사용, 클라이언트에서 요청하는 데이터 처리 |
| 통신  | HTTP 통한 Client - server 통신 | HTTP,Web Socket 통한 Client - server 통신 |
| READ | RESTful 엔드포인트는 고정 데이터 구조 반환              |  클라이언트가 쿼리를 통해 특정 데이터를 요청할 때 그 데이터에 상응하는 구조 반환             |
| UPDATES   | HTTP 메소드 이용(PUT, POST, DELETE) | mutation 이용한 데이터 변경          |
| return Data 형태     | Endpoint 가 결정          | Client 가 결정            |
| 캐시가능        | RESTful API 는 endpoint 단계에서 캐시 가능 | GraphQL response 는 endpoint 단계에서 캐시 불가 |
| Overfetching<br>(과한 데이터 가져오기)  | RESTful APIs는 불필요한 데이터도 균일한 인터페이스 제약 때문에 종종 포함됨             | GraphQL query는 오직 필요한 데이터만 요청 |
| Underfetching<br>(API 요청 하나로 부족) | RESTful API 는 필요 데이터를 위해 추가요청 필요할수도 | GraphQL query 는 한 요청에 필요한 모든 데이터 가져오기 가능 |
| 스키마         | 필요없음                          | GraphQL API는 type / field 정의 위한 스키마 필요     |

## SRP(단일 책임 원칙)

모든 클래스는 각각 하나의 변경 원인,근거(책임)를 가지고, 그것을 캡슐화(속성 행위를 묶어서 외부에 보이지 않게 숨김)해야 한다.

React의 경우에는 관련 있는 UI/작업 들만 component 로 묶어버린다. 관련이 없는 다른 작업들은 다른 component로 분리를 하면 각 컴포넌트들을 재사용할 수 있고 유지보수성도 좋아진다.

CSS, layer 에 따라서 어떻게 조직할지 결정을 한다.

IA의 경우 API에서 받아오는 잘 구조화된 데이터(JSON Schema) 영향으로 컴포넌트 계층을 나누게 된다. 나누는 과정에서 관련 있는 데이터 끼리 묶게 되다보니 SRP 원칙이 자연스럽게 녹아들 수 밖에 없다.

## Atomic Design

웹 디자인시에 계층형 구조로 나눌 때 화학에서의 맥락을 집어넣었다.

1. atom(원자) : 물질을 이루는 가장 작은 단위. 기본적인 마크업 하나를 뜻한다. 색상 정보, 폰트, animation 같은 추상적인 요소도 atom 단위로 포함된다.
2. molecule(분자) : 두개 이상의 원자가 일정한 형태로 결합한 것. atom 이 여러개 모인 것들의 묶음이고, 재사용을 위해 만들어진 비교적 단순한 조합이다.
3. organism(유기체) : molcule이 여러개 보여서 만든 뚜렷한 인터페이스 부분
4. template : organism의 그룹. 디자인이 완성되고 레이아웃이 실제로 작동함. 4단계에서는 화학비유를 안쓰기 시작한다.
5. page : placeholder의 content가 실제 대표 컨텐츠로 대체됨. 사용자가 최종적으로 보는 모습을 정확히 묘사한다.

컴포넌트 계층 구조를 나눌 때 꼭 완전히 적용하는 것이 아니더라도 참고하면 좋을 것 같다.

## React component 와 props

정적 버전의 앱을 만들시 component를 재사용하고 props로 data를 전달해서 새로운 component를 만드는 것이 좋다. props는 부모 component에서 자식으로 단방향으로 전달된다.

그리고 계층구조에서 빌드는 규모에따라서 크면 상향식,  작으면 하향식으로 가는 것이 좋다.

## inline function이 쓰이는 경우

inline function - 함수 호출 부분에 코드를 박아버린 함수. 호출시 발생하는 오버헤드가 없다.

* 한번만 쓰는 경우 - 재사용할 여지 없을 때 호출 오버헤드를 제거한다.
* 나누기 애매할때 - SRP를 위해 굳이 나눠야할까 싶을 정도로 애매할 때.

## reference

* [REST-wiki](https://ko.wikipedia.org/wiki/REST)
* [REST-NAVER d2](https://www.youtube.com/watch?v=RP_f5dMoHFc&t=9s)
* [DSL](https://www.jetbrains.com/ko-kr/mps/concepts/domain-specific-languages/)
